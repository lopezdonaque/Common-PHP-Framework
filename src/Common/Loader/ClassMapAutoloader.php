<?php

namespace Common\Loader;


/**
 * This class helps to autoload classes from a single classmap autogenerated file.
 * This should be used as the last autoload option.
 * This is a wrapper of the "Zend2 ClassMapAutoloader" class.
 * Uses the "Zend2 ClassMapAutoloader" as default autoloader but also generates the classmap files for each defined path
 * when a class is not found.
 *
 */
class ClassMapAutoloader
{

  /**
   * Classmap file
   *
   * @var string
   */
  private $_classmap_file;


  /**
   * Directories to search for classes
   *
   * @var array
   */
  private $_paths;


  /**
   * ClassMapAutoloader instance
   *
   * @var \Zend\Loader\ClassMapAutoloader
   */
  private $_loader;


  /**
   * Observable instance
   *
   * @var \Common\Utils\Observable
   */
  public $observable;


  /**
   * List of classes to ignore
   *
   * @var array
   */
  public static $ignore_classes = array
  (
    'WeakRef' // Used by Zend 2 (http://php.net/manual/es/class.weakref.php)
  );



  /**
   * Constructor
   *
   * @param string $classmap_file
   * @param array $paths
   */
  public function __construct( $classmap_file, $paths = array() )
  {
    $this->observable = new \Common\Utils\Observable();
    $this->_classmap_file = $classmap_file;
    $this->_paths = $paths;

    if( !file_exists( $classmap_file ) )
    {
      file_put_contents( $classmap_file, '<?php return array();' );
    }
  }



  /**
   * Registers autoload
   */
  public function register()
  {
    $this->_loader = new \Zend\Loader\ClassMapAutoloader();
    $this->_loader->registerAutoloadMap( $this->_classmap_file );
    $this->_loader->register();

    // Register the fallback autoload which regenerates the classmap file and loads the class
    spl_autoload_register( array( $this, 'load_class' ) );
  }



  /**
   * Loads a class
   *
   * @param string $class
   */
  public function load_class( $class )
  {
    if( in_array( $class, self::$ignore_classes ) )
    {
      return;
    }

    // Check if the class is mapped
    $map = $this->_loader->getAutoloadMap();
    if( !isset( $map[ $class ] ) )
    {
      $building_file = $this->_classmap_file . '.building';

      // Check if it's building the classmap
      if( file_exists( $building_file ) )
      {
        return;
      }

      file_put_contents( $building_file, '' );
      $this->observable->fireEvent( 'before_build', $class );
      $this->build_classmap();
      unlink( $building_file );

      // Reregister Zend Loader to reload the "mapsLoaded" property"
      spl_autoload_unregister( array( $this->_loader, 'load_class' ) );
      $this->register();
    }

    $this->_loader->autoload( $class );
  }



  /**
   * Builds classmap file
   * This is based on "classmap_generator.php" from "Zend 2".
   */
  public function build_classmap()
  {
    // Iterate over each element in each path, and create a map of classname => filename,
    // where the filename is relative to the library path
    $map = new \stdClass();

    foreach( $this->_paths as $libraryPath )
    {
      // Get the ClassFileLocator, and pass it the library path
      $l = new \Zend\File\ClassFileLocator( $libraryPath );

      foreach( $l as $file ) /* @var $file \Zend\File\PhpClassFile */
      {
        $filename = $file->getPathname();

        foreach( $file->getClasses() as $class )
        {
          $map->{$class} = $filename;
        }
      }
    }

    // Create a file with the class/file map.
    // Stupid syntax highlighters make separating < from PHP declaration necessary
    $content = '<' . "?php\n"
             . "// Generated by CommonPHP Framework\n"
             . 'return ' . var_export((array) $map, true) . ';';

    // Fix \' strings from injected DIRECTORY_SEPARATOR usage in iterator_apply op
    $content = str_replace("\\'", "'", $content);

    // Remove unnecessary double-backslashes
    $content = str_replace('\\\\', '\\', $content);

    // Exchange "array (" width "array("
    $content = str_replace('array (', 'array(', $content);

    // Align "=>" operators to match coding standard
    preg_match_all('(\n\s+([^=]+)=>)', $content, $matches, PREG_SET_ORDER);
    $maxWidth = 0;

    foreach ($matches as $match) {
        $maxWidth = max($maxWidth, strlen($match[1]));
    }

    $content = preg_replace('(\n\s+([^=]+)=>)e', "'\n    \\1' . str_repeat(' ', " . $maxWidth . " - strlen('\\1')) . '=>'", $content);

    // Write the contents to disk
    $output = $this->_classmap_file;
    file_put_contents($output, $content);
  }

}
